//@version=5
// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License https://creativecommons.org/licenses/by-sa/4.0/
// © dman103
// MA+ is a multi time frame moving average indicator with more than a dozen different moving averages. More moving averages will be added on every update, hence Follow me to get notified.
// MA+ Supports automatic (AUTO in settings) time frame multiplier. For example, if you set 'Auto Resolution Multiplier' to 6, and your base chart is 5 minutes, the moving averages will plot at 5 * 6 = 30 minutes.
// You can still use 'User Defined' to use your own time frame without using the multiplier.
// Use higher time frames than base chart time frame to avoid repainting.
// Default multiplier for higher time frame is 2.
// Supports Signals 1 (rising MA) or -1 (falling MA) to attach to another indicator.
// Bars are not colored by default.
// Just for this great community, You can request in comments other moving averages that do not exist now.
// Like if you like and Follow for upcoming indicators/strategies: https://www.tradingview.com/u/dman103/
indicator(title='MA+', shorttitle='MA+', overlay=true)
// Get user input
ma_select = input.string(title='Moving Average Type', defval='EMA', options=['SMA', 'EMA', 'WMA', 'HMA', 'JMA', 'KAMA', 'TMA', 'VAMA', 'SMMA', 'DEMA', 'VMA', 'WWMA', 'EMA_NO_LAG', 'TSF', 'ALMA'], group='MAIN Parameters')
src = input.source(title='Source', defval=close, group='MAIN Parameters')
htf_is_auto = input.string(title='Higher Timeframe Period', defval='None', options=['None','Auto', 'User Defined'], group='MAIN Parameters')
res_multi = input.int(title='Auto Resolution Multiplier', defval=2, minval=1, group='MAIN Parameters', tooltip='Will multiple your currnet time frame by this value.')
user_tf = input.timeframe(title='User Defined Timeframe', defval='', group='MAIN Parameters')
len = input.int(title='MA Length', defval=7, group='MAIN Parameters')
signal_type = input.string("Line ascending or descending",'Signal type (line color and signals)',options=['Line ascending or descending', 'Price above or below moving average','Price above or below ATR channel'],group='MAIN Parameters')
//last_bar_for_realtime = input.bool(true, title='Last bar will be affected by price changes (Realtime bars)', group='MAIN Parameters', tooltip='Enable this option to see real-time changes on the moving average on the last bar (the most recent one), otherwise, the moving average on the last bar wont be affected by price changes.')
show_atr_channel = input.bool(true, title="Show ATR channel", group="ATR channel")
atr_length=  input.int(14, title="ATR Length", group="ATR channel")
atr_multiplier = input.float(0.5, title="ATR multiplier", step=0.25, group="ATR channel")
atr_channel_fill_color = input.bool(true, title="Fill ATR channel", group="ATR channel")
gray_middle_area = input.bool(false, title="Gray in case price inside ATR channel", tooltip="Will affect when 'Price above or below ATR channe' is selected.", group="ATR channel")
show_signals = input.bool(false,title="Show Buy/Sell signals", group='General MA Parameters')
col_ma = input.bool(title='Color MA', defval=true, group='General MA Parameters')
col_bars = input.bool(title='Color bars', defval=false, group='General MA Parameters')
line_width = input.int(title='Line width', minval=1, defval=3, group='General MA Parameters')

offset = input.float(title='Alma Offset (only for ALMA)', defval=0.85, step=0.05, group='Other MA Parameters')
volatility_lookback = input.int(title='Volatility lookback (only for VAMA)', defval=12, group='Other MA Parameters')
i_fastAlpha = input.float(3, 'KAMA\'s alpha (only for KAMA)', minval=1, step=0.5, group='Other MA Parameters')

fastAlpha = 2.0 / (i_fastAlpha + 1)
slowAlpha = 2.0 / 31
f_multiple_resolution(_mult) =>
    target_Res_In_Min = timeframe.multiplier * _mult * (timeframe.isseconds ? 1. / 60. : timeframe.isminutes ? 1. : timeframe.isdaily ? 1440. : timeframe.isweekly ? 7. * 24. * 60. : timeframe.ismonthly ? 30.417 * 24. * 60. : na)

    target_Res_In_Min <= 0.0417 ? '1S' : target_Res_In_Min <= 0.167 ? '5S' : target_Res_In_Min <= 0.376 ? '15S' : target_Res_In_Min <= 0.751 ? '30S' : target_Res_In_Min <= 1440 ? str.tostring(math.round(target_Res_In_Min)) : str.tostring(math.round(math.min(target_Res_In_Min / 1440, 365))) + 'D'
res = htf_is_auto == 'Auto' ? f_multiple_resolution(res_multi) : htf_is_auto=='User Defined' ?   user_tf: timeframe.period

///////Moving Averages
MA_selector(src, length) =>
    ma = 0.0
    if ma_select == 'SMA'
        ma := ta.sma(src, length)
        ma

    else if ma_select == 'EMA'
        ma := ta.ema(src, length)
        ma

    else if ma_select == 'WMA'
        ma := ta.wma(src, length)
        ma
    else if ma_select == 'HMA'
        ma := ta.hma(src, length)
        ma
    else if ma_select == 'JMA'
        beta = 0.45 * (length - 1) / (0.45 * (length - 1) + 2)
        alpha = beta
        tmp0 = 0.0
        tmp1 = 0.0
        tmp2 = 0.0
        tmp3 = 0.0
        tmp4 = 0.0
        tmp0 := (1 - alpha) * src + alpha * nz(tmp0[1])
        tmp1 := (src - tmp0[0]) * (1 - beta) + beta * nz(tmp1[1])
        tmp2 := tmp0[0] + tmp1[0]
        tmp3 := (tmp2[0] - nz(tmp4[1])) * (1 - alpha) * (1 - alpha) + alpha * alpha * nz(tmp3[1])
        tmp4 := nz(tmp4[1]) + tmp3[0]
        ma := tmp4
        ma
    else if ma_select == 'KAMA'
        momentum = math.abs(ta.change(src, length))
        volatility = math.sum(math.abs(ta.change(src)), length)
        efficiencyRatio = volatility != 0 ? momentum / volatility : 0
        smoothingConstant = math.pow(efficiencyRatio * (fastAlpha - slowAlpha) + slowAlpha, 2)
        var kama = 0.0
        kama := nz(kama[1], src) + smoothingConstant * (src - nz(kama[1], src))
        ma := kama
        ma
    else if ma_select == 'TMA'
        ma := ta.sma(ta.sma(src, math.ceil(length / 2)), math.floor(length / 2) + 1)
        ma
    else if ma_select == 'VMA'
        valpha = 2 / (length + 1)
        vud1 = src > src[1] ? src - src[1] : 0
        vdd1 = src < src[1] ? src[1] - src : 0
        vUD = math.sum(vud1, 9)
        vDD = math.sum(vdd1, 9)
        vCMO = nz((vUD - vDD) / (vUD + vDD))
        VAR = 0.0
        VAR := nz(valpha * math.abs(vCMO) * src) + (1 - valpha * math.abs(vCMO)) * nz(VAR[1])
        ma := VAR
        ma

    else if ma_select == 'WWMA'
        wwalpha = 1 / length
        WWMA = 0.0
        WWMA := wwalpha * src + (1 - wwalpha) * nz(WWMA[1])
        ma := WWMA
        ma

    else if ma_select == 'EMA_NO_LAG'
        EMA1 = ta.ema(src, length)
        EMA2 = ta.ema(EMA1, length)
        Difference = EMA1 - EMA2
        ma := EMA1 + Difference
        ma

    else if ma_select == 'TSF'
        lrc = ta.linreg(src, length, 0)
        lrc1 = ta.linreg(src, length, 1)
        lrs = lrc - lrc1
        TSF = ta.linreg(src, length, 0) + lrs
        ma := TSF
        ma

    // Volatility Adjusted from @fractured
    else if ma_select == 'VAMA'
        mid = ta.ema(src, length)
        dev = src - mid
        vol_up = ta.highest(dev, volatility_lookback)
        vol_down = ta.lowest(dev, volatility_lookback)
        ma := mid + math.avg(vol_up, vol_down)
        ma
    else if ma_select == 'SMMA'
        smma = float(0.0)
        smaval = ta.sma(src, length)
        smma := na(smma[1]) ? smaval : (smma[1] * (length - 1) + src) / length
        ma := smma
        ma

    else if ma_select == 'DEMA'
        e1 = ta.ema(src, length)
        e2 = ta.ema(e1, length)
        ma := 2 * e1 - e2
        ma
    else if ma_select == 'ALMA'
        ma := ta.alma(src, length, offset, 6)
        ma

    ma
// Calculate MA
ma = MA_selector(src, len)
atr_val= ta.atr(atr_length)
maStep = request.security(syminfo.tickerid, res,ma)// ma[barstate.isrealtime and last_bar_for_realtime == false ? 1 : 0])
atrStep = request.security(syminfo.tickerid, res,atr_val)// atr_val[barstate.isrealtime and last_bar_for_realtime == false ? 1 : 0])
atr_up_channel=ma +(atrStep*atr_multiplier)
atr_down_channel=ma -(atrStep*atr_multiplier)

var int signal = 0
var plot_color = color.white
if (signal_type=='Line ascending or descending')
    if maStep != maStep[1]
        if maStep > maStep[1]
            signal := 1
            plot_color := color.green
        else if maStep < maStep[1]
            signal := -1
            plot_color := color.red
else if signal_type=='Price above or below moving average'
    if(close>maStep)
        signal := 1
        plot_color := color.green
    else if (close<maStep)
        signal := -1
        plot_color := color.red
else
    if (close> atr_up_channel)
        signal:=1
        plot_color := color.green
    else if (close< atr_down_channel)
        signal:=-1
        plot_color := color.red
    else if (gray_middle_area)
        signal:=0
        plot_color:=color.gray




//atr_channel_color = atr_up_channel>=atr_up_channel[1] and atr_down_channel>=atr_down_channel[1] ? color.new(color.green, 80) :  atr_up_channel<atr_up_channel[1] and atr_down_channel<atr_down_channel[1]? color.new(color.red,80) : color.new(color.white,80)
high_atr_plot=plot(show_atr_channel? atr_up_channel : na, color=color.new(plot_color,25),linewidth=1)
low_atr_plot=plot(show_atr_channel? atr_down_channel : na, color=color.new(plot_color,25),linewidth=1)

fill(high_atr_plot,low_atr_plot,atr_channel_fill_color ?  color.new(plot_color,90) : na)
plot(maStep, color=col_ma ? plot_color : color.blue, linewidth=line_width, title='MA')
barcolor(color=col_bars ? plot_color : na)

plot(signal, title='Signal 1 or -1 or 0 (no change)', display=display.none)
sig = signal != signal[1] ? signal : 0
alertcondition(sig == 1, title='Green line ascending ↑')
alertcondition(sig == -1, title='Ren line descending ↓')
alertcondition(sig == -1 or sig == 1, title='Green/Red changed ↕')
//show_signals
plotshape(sig==1  and show_signals ,location=location.belowbar, style=shape.labelup, color=color.green,size=size.small)
plotshape(sig==-1  and show_signals,location=location.abovebar, style=shape.labeldown, color=color.red,size=size.small)


