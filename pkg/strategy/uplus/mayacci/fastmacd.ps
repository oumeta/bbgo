// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© SoftKill21

//@version=4
strategy("btc 1min strat RISK %% ", overlay=false, initial_capital = 1000)

// BACKTESTING RANGE
 
// From Date Inputs
fromDay = input(defval = 1, title = "From Day", minval = 1, maxval = 31)
fromMonth = input(defval = 1, title = "From Month", minval = 1, maxval = 12)
fromYear = input(defval = 2022, title = "From Year", minval = 1970)
 
// To Date Inputs
toDay = input(defval = 1, title = "To Day", minval = 1, maxval = 31)
toMonth = input(defval = 12, title = "To Month", minval = 1, maxval = 12)
toYear = input(defval = 2022, title = "To Year", minval = 1970)
 
// Calculate start/end date and time condition
DST = 1 //day light saving for usa
//--- Europe
London = iff(DST==0,"0000-0900","0100-1000")
//--- America
NewYork = iff(DST==0,"0400-1500","0500-1600")
//--- Pacific
Sydney = iff(DST==0,"1300-2200","1400-2300")
//--- Asia
Tokyo = iff(DST==0,"1500-2400","1600-0100")

//-- Time In Range
timeinrange(res, sess) => time(res, sess) != 0

london = timeinrange(timeframe.period, London)
newyork = timeinrange(timeframe.period, NewYork)

startDate = timestamp(fromYear, fromMonth, fromDay, 00, 00)
finishDate = timestamp(toYear, toMonth, toDay, 00, 00)
time_cond = time >= startDate and time <= finishDate and (london or newyork)
// 
// 


// rsi
length = input( 5 )
overSold = input( 23 )
overBought = input( 72 )
price = close

vrsi = rsi(price, length)
co = crossover(vrsi, overSold)
cu = crossunder(vrsi, overBought)

// macd
fast_length_macd = input(title="Fast Length", type=input.integer, defval=12)
slow_length_macd = input(title="Slow Length", type=input.integer, defval=26)
src_macd = input(title="Source", type=input.source, defval=close)
signal_length = input(title="Signal Smoothing", type=input.integer, minval = 1, maxval = 50, defval = 9)
sma_source = input(title="Simple MA(Oscillator)", type=input.bool, defval=true)
sma_signal = input(title="Simple MA(Signal Line)", type=input.bool, defval=true)

// Plot colors
col_grow_above = #26A69A
col_grow_below = #FFCDD2
col_fall_above = #B2DFDB
col_fall_below = #EF5350
col_macd = #0094ff
col_signal = #ff6a00

// Calculating
fast_ma = sma_source ? sma(src_macd, fast_length_macd) : ema(src_macd, fast_length_macd)
slow_ma = sma_source ? sma(src_macd, slow_length_macd) : ema(src_macd, slow_length_macd)
macd = fast_ma - slow_ma
signal = sma_signal ? sma(macd, signal_length) : ema(macd, signal_length)
hist = macd - signal

//plot(hist, title="Histogram", style=plot.style_columns, color=(hist>=0 ? (hist[1] < hist ? col_grow_above : col_fall_above) : (hist[1] < hist ? col_grow_below : col_fall_below) ), transp=0 )


// sar
start = input(0.02)
increment = input(0.02)
maximum = input(0.2)

var bool uptrend = na
var float EP = na
var float SAR = na
var float AF = start
var float nextBarSAR = na

if bar_index > 0
    firstTrendBar = false
    SAR := nextBarSAR
    
    if bar_index == 1
        float prevSAR = na
        float prevEP = na
        lowPrev = low[1]
        highPrev = high[1]
        closeCur = close
        closePrev = close[1]

        if closeCur > closePrev
            uptrend := true
            EP := high
            prevSAR := lowPrev
            prevEP := high
        else
            uptrend := false
            EP := low
            prevSAR := highPrev
            prevEP := low
        
        firstTrendBar := true
        SAR := prevSAR + start * (prevEP - prevSAR)
    
    if uptrend
        if SAR > low
            firstTrendBar := true
            uptrend := false
            SAR := max(EP, high)
            EP := low
            AF := start
    else
        if SAR < high
            firstTrendBar := true
            uptrend := true
            SAR := min(EP, low)
            EP := high
            AF := start
    
    if not firstTrendBar
        if uptrend
            if high > EP
                EP := high
                AF := min(AF + increment, maximum)
        else
            if low < EP
                EP := low
                AF := min(AF + increment, maximum)
    
    if uptrend
        SAR := min(SAR, low[1])
        if bar_index > 1
            SAR := min(SAR, low[2])
    else
        SAR := max(SAR, high[1])
        if bar_index > 1
            SAR := max(SAR, high[2])
    
    nextBarSAR := SAR + AF * (EP - SAR)
    


//plot(SAR, style=plot.style_cross, linewidth=3, color=color.orange)
//plot(nextBarSAR, style=plot.style_cross, linewidth=3, color=color.aqua)
//plot(strategy.equity, title="equity", color=color.red, linewidth=2, style=plot.style_areabr)

//bb
length_bb = input(17, minval=1)
src_bb = input(close, title="Source")
mult_bb = input(2.0, minval=0.001, maxval=50, title="StdDev")
basis_bb = sma(src_bb, length_bb)
dev_bb = mult_bb * stdev(src_bb, length_bb)
upper_bb = basis_bb + dev_bb
lower_bb = basis_bb - dev_bb
offset = input(0, "Offset", type = input.integer, minval = -500, maxval = 500)
//plot(basis_bb, "Basis", color=#872323, offset = offset)
//p1_bb = plot(upper_bb, "Upper", color=color.teal, offset = offset)
//p2_bb = plot(lower_bb, "Lower", color=color.teal, offset = offset)

//fill(p1_bb, p2_bb, title = "Background", color=#198787, transp=95)

//ema

len_ema = input(10, minval=1, title="Length")
src_ema = input(close, title="Source")
offset_ema = input(title="Offset", type=input.integer, defval=0, minval=-500, maxval=500)
out_ema = ema(src_ema, len_ema)
//plot(out_ema, title="EMA", color=color.blue, offset=offset_ema) 
//out_ema e emaul
//basis_bb e middle de la bb
//hist e histograma
// rsi cu band0 cross pt rsi

// confirmarea

shortCondition = (uptrend==false and crossunder(ema(src_ema, len_ema),sma(src_bb, length_bb)) and  hist < 0  and vrsi <   overSold) //and time_cond
longCondition = (uptrend==true and crossover(ema(src_ema, len_ema),sma(src_bb, length_bb))  and hist > 0 and vrsi >  overBought ) //and time_cond

//tp=input(0.0025,type=input.float, title="tp")
//sl=input(0.001,type=input.float, title="sl")

//INDICATOR---------------------------------------------------------------------    
    //Average True Range (1. RISK)
atr_period = input(14, "Average True Range Period")
atr = atr(atr_period)

//MONEY MANAGEMENT--------------------------------------------------------------
balance = strategy.netprofit + strategy.initial_capital //current balance
floating = strategy.openprofit          //floating profit/loss
risk = input(2,type=input.float,title="Risk %")/100           //risk % per trade
isTwoDigit = input(false,"Is this a 2 digit pair? (JPY, XAU, XPD...")

equity_protector = input(1 ,type=input.float, title="Equity Protection %")/100  //equity protection %
equity_protectorTP = input(2 ,type=input.float, title="Equity TP %")/100  //equity protection %
multtp = input(5,type=input.float, title="multi atr tp")
multsl = input(5,type=input.float, title="multi atr sl")
stop = atr*100000*input(1,"SL X")* multsl    //Stop level
if(isTwoDigit)
    stop := stop/100
target = atr*100000*input(1,"TP X")*multtp    //Stop level
    //Calculate current DD and determine if stopout is necessary
equity_stopout = false

if(floating<0 and abs(floating/balance)>equity_protector)
    equity_stopout := true
    
equity_stopout2 = false
if(floating>0 and abs(floating/balance)>equity_protectorTP)
    equity_stopout2 := true
    
    //Calculate the size of the next trade
temp01 = balance * risk     //Risk in USD
temp02 = temp01/stop        //Risk in lots
temp03 = temp02*100000      //Convert to contracts
size = temp03 - temp03%1000 //Normalize to 1000s (Trade size)
if(size < 10000)
    size := 10000           //Set min. lot size

//TRADE EXECUTION---------------------------------------------------------------
strategy.close_all(equity_stopout, comment="equity sl", alert_message = "equity_sl")      //Close all trades w/equity protector
//strategy.close_all(equity_stopout2, comment="equity tp", alert_message = "equity_tp")      //Close all trades w/equity protector
is_open = strategy.opentrades > 0


strategy.entry("long",true,size,oca_name="a",oca_type=strategy.oca.cancel,when=longCondition and not is_open)  //Long entry
strategy.entry("short",false,size,oca_name="a",oca_type=strategy.oca.cancel,when=shortCondition and not is_open) //Short entry
    
strategy.exit("exit_long","long",loss=stop, profit=target)      //Long exit (stop loss)
strategy.close("long",when=shortCondition)            //Long exit (exit condition)
strategy.exit("exit_short","short",loss=stop, profit=target)      //Short exit (stop loss)
strategy.close("short",when=longCondition)            //Short exit (exit condition)


//strategy.entry("long", strategy.long,size,when=longCondition , comment="long" , alert_message = "long")
//strategy.entry("short", strategy.short, size,when=shortCondition , comment="short" , alert_message = "short")
 
//strategy.exit("closelong", "long" , profit = close * tp / syminfo.mintick,  alert_message = "closelong")
//strategy.exit("closeshort", "short" , profit = close * tp / syminfo.mintick, alert_message = "closeshort")
 
//strategy.exit("closelong", "long" ,size, profit = close * tp / syminfo.mintick, loss = close * sl / syminfo.mintick, alert_message = "closelong")
//strategy.exit("closeshort", "short" , size, profit = close * tp / syminfo.mintick, loss = close * sl / syminfo.mintick, alert_message = "closeshort")
 
//strategy.close("long" , when=not (time_cond), comment="time", alert_message = "closelong" )
//strategy.close("short" , when=not (time_cond), comment="time", alert_message = "closeshort")
//strategy.close_all(when=not (time_cond), comment ='time')

